[{"slug":"MD测试文档","category":"blog","title":"MD测试文档","description":"MD测试文档","body":"# 欢迎使用马克飞象\n\n@(示例笔记本)[马克飞象|帮助|Markdown]\n\n**马克飞象**是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：\n \n- **功能丰富** ：支持高亮代码块、*LaTeX* 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；\n- **得心应手** ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web；\n- **深度整合** ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。\n\n-------------------\n\n[TOC]\n\n::::card\n横排排版演示\n:::card-title\n横排排版演示\n:::\n::::\n\n::::card{#vertical}\n竖排排版演示\n:::card-title\n竖排排版演示\n:::\n::::\n\n::::card{#vertical.center}\n竖排居中排版演示\n:::card-title\n竖排居中排版演示\n:::\n::::\n\n## Markdown简介\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— [维基百科](https://zh.wikipedia.org/wiki/Markdown)\n\n正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为**粗体**或者*斜体*，创建一个[链接](http://www.example.com)或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按`Ctrl + /`查看帮助。 \n\n### 代码块\n``` python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    '''A docstring'''\n    if param1 > param2: # interesting\n        print 'Greater'\n    return (param2 - param1 + 1) or None\nclass SomeClass:\n    pass\n>>> message = '''interpreter\n... prompt'''\n```\n### LaTeX 公式\n\n可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式：\n\n$$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n\n### 表格\n| Item      |    Value | Qty  |\n| :-------- | --------:| :--: |\n| Computer  | 1600 USD |  5   |\n| Phone     |   12 USD |  12  |\n| Pipe      |    1 USD | 234  |\n\n### 流程图\n```flow\nflowchart TD\n    A[/Christmas\\]\n    A -->|Get money| B[\\Go shopping/]\n    B --> C{Let me thinksssss<br/>ssssssssssssssssssssss<br/>sssssssssssssssssssssssssss}\n    C -->|One| D[/Laptop/]\n    C -->|Two| E[\\iPhone\\]\n    C -->|Three| F[Car]\n```\n\n以及时序图:\n\n```sequence\nsequenceDiagram\n\t\t\taccTitle: test the accTitle\n\t\t\taccDescr: Test a description\n\n\t\t\tparticipant Alice\n\t\t\tparticipant Bob\n\t\t\tparticipant John as John<br />Second Line\n\t\t\tautonumber 10 10\n\t\t\trect rgb(200, 220, 100)\n\t\t\trect rgb(200, 255, 200)\n\n\t\t\tAlice ->> Bob: Hello Bob, how are you?\n\t\t\tBob-->>John: How about you John?\n\t\t\tend\n\n\t\t\tBob--x Alice: I am good thanks!\n\t\t\tBob-x John: I am good thanks!\n\t\t\tNote right of John: John thinks a long<br />long time, so long<br />that the text does<br />not fit on a row.\n\n\t\t\tBob-->Alice: Checking with John...\n\t\t\tNote over John:wrap: John looks like he's still thinking, so Bob prods him a bit.\n\t\t\tBob-x John: Hey John - we're still waiting to know<br />how you're doing\n\t\t\tNote over John:nowrap: John's trying hard not to break his train of thought.\n\t\t\tBob-x John:wrap: John! Are you still debating about how you're doing? How long does it take??\n\t\t\tNote over John: After a few more moments, John<br />finally snaps out of it.\n\t\t\tend\n\n\t\t\tautonumber off\n\t\t\talt either this\n\t\t\tAlice->>+John: Yes\n\t\t\tJohn-->>-Alice: OK\n\t\t\telse or this\n\t\t\tautonumber\n\t\t\tAlice->>John: No\n\t\t\telse or this will happen\n\t\t\tAlice->John: Maybe\n\t\t\tend\n\t\t\tautonumber 200\n\t\t\tpar this happens in parallel\n\t\t\tAlice -->> Bob: Parallel message 1\n\t\t\tand\n\t\t\tAlice -->> John: Parallel message 2\n\t\t\tend\n```\n\n> **提示：**想了解更多，请查看**流程图**[语法][3]以及**时序图**[语法][4]。\n\n### 复选框\n\n使用 `- [ ]` 和 `- [x]` 语法可以创建复选框，实现 todo-list 等功能。例如：\n\n- [x] 已完成事项\n- [ ] 待办事项1\n- [ ] 待办事项2\n\n> **注意：**目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在**马克飞象**中修改 Markdown 原文才可生效。下个版本将会全面支持。\n\n\n## 印象笔记相关\n\n### 笔记本和标签\n**马克飞象**增加了`@(笔记本)[标签A|标签B]`语法, 以选择笔记本和添加标签。 **绑定账号后**， 输入`(`自动会出现笔记本列表，请从中选择。\n\n### 笔记标题\n**马克飞象**会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 `欢迎使用马克飞象`。\n\n### 快捷编辑\n保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到**马克飞象**中打开并编辑该笔记。\n>**注意：**目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。\n\n### 数据同步\n**马克飞象**通过**将Markdown原文以隐藏内容保存在笔记中**的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。\n\n >**隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。**\n\n### 离线存储\n**马克飞象**使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过`文档管理`打开。\n\n> **注意：**虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，**请务必经常及时同步到印象笔记**。\n\n## 编辑器相关\n### 设置\n右侧系统菜单（快捷键`Ctrl + M`）的`设置`中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。\n\n### 快捷键\n\n帮助    `Ctrl + /`\n同步文档    `Ctrl + S`\n创建文档    `Ctrl + Alt + N`\n最大化编辑器    `Ctrl + Enter`\n预览文档 `Ctrl + Alt + Enter`\n文档管理    `Ctrl + O`\n系统菜单    `Ctrl + M` \n\n加粗    `Ctrl + B`\n插入图片    `Ctrl + G`\n插入链接    `Ctrl + L`\n提升标题    `Ctrl + H`\n\n## 关于收费\n\n**马克飞象**为新用户提供 10 天的试用期，试用期过后需要[续费](maxiang.info/vip.html)才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。\n\n\n## 反馈与建议\n- 微博：[@马克飞象](http://weibo.com/u/2788354117)，[@GGock](http://weibo.com/ggock \"开发者个人账号\")\n- 邮箱：<hustgock@gmail.com>\n\n---------\n感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。\n\n\n\n\n[^demo]: 这是一个示例脚注。请查阅 [MultiMarkdown 文档](https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes) 关于脚注的说明。 **限制：** 印象笔记的笔记内容使用 [ENML][5] 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致`脚注`和`TOC`无法正常点击。\n\n\n  [1]: http://maxiang.info/client_zh\n  [2]: https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop\n  [3]: http://adrai.github.io/flowchart.js/\n  [4]: http://bramp.github.io/js-sequence-diagrams/\n  [5]: https://dev.yinxiang.com/doc/articles/enml.php\n\n"},{"slug":"PureWiki主题","category":"blog","title":"PureWiki主题","description":"一个简单的主题","body":"\n[TOC]\n\n对于该主题，主要目的是为可展示文章的，提供一个树状菜单，可以简单当作一个界面纯净的Wiki。\n\n界面总感觉有点怪怪的。\n\n## 特性\n\n1. 文章可用元输入如下（有一些其他的，可以自己看代码，tpyings尚不完善，得看布局代码）\n    ```\n    title: Markdown测试       <!-- 必须，文章标题 -->\n    description: 描述         <!-- 描述，可用作seo，文章中暂未展示 -->\n    pubDate: 2022/5/12        <!-- 发布日期 -->\n    updatedDate: 2023/01/01   <!-- 修改日期-->\n    heroImage: \"\"             <!-- 文章头图 -->\n    top: true                 <!-- 展示在右上方 -->\n    mode: chinese             <!-- 首行缩进 -->\n    mode: collect             <!-- 文章不被rss收录 -->\n    ```\n\n2. 使用如下代码，会被标题替换，支持三级标题\n    ```\n    [TOC]\n    ```\n3. 内部已支持了`markdown`命令转化为`html`了\n    ```\n    :abbr[提示]{title=\"提示\"}\n    ```\n    效果：:abbr[提示]{title=\"提示\"}\n4. 支持面板\n    ```\n    ::::card\n    横排排版演示\n    :::card-title\n    横排排版演示\n    :::\n    ::::\n\n    ::::card{#vertical}\n    竖排排版演示\n    :::card-title\n    竖排排版演示\n    :::\n    ::::\n\n    ::::card{#vertical.center}\n    竖排居中排版演示\n    :::card-title\n    竖排居中排版演示\n    :::\n    ::::\n    ```\n    横排已经可以了，竖排感觉也没啥用。\n5. 可配置头图为文章中的第一张图片，只需要将配置的`showArticleHeroImage`设置为true即可。\n6. 文章提供了直接在github编辑功能，自行配置即可\n7. 增加`mermaid`渲染流程图时序图（暂时提供两个）\n    ```\n        ```flow\n        flowchart TD\n            A[/Christmas\\]\n            A -->|Get money| B[\\Go shopping/]\n            B --> C{Let me thinksssss<br/>ssssssssssssssssssssss<br/>sssssssssssssssssssssssssss}\n            C -->|One| D[/Laptop/]\n            C -->|Two| E[\\iPhone\\]\n            C -->|Three| F[Car]\n        ```\n    ```\n    ```\n        ```sequence\n        ```\n    ```\n8. 增加`mathjax`渲染公式\n    ```\n    $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$\n\n    $$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n    ```\n9. 提供`iframe`命令和`iframec`命令  \n    `iframe`为收缩框默认打开  \n    `iframec`为收缩框默认关闭\n    ```\n    ::iframe[流程图Demo]{url=/demo/flowchart.html}\n    ::iframec[流程图Demo]{url=/demo/flowchart.html}\n    ```\n    目前版本能够展示url的网页,效果如下：\n    ::iframe[流程图Demo]{url=/demo/flowchart.html}\n    ::iframec[时序图]{url=/demo/sequence-diagrams.html}\n\n    ::iframe[BiliBili]{url=\"//player.bilibili.com/player.html?aid=690345969&bvid=BV1N24y117QE&cid=895902728&page=1\"}\n\n10. 提供`demo`命令\n\n    ```\n        :::demo\n        ```html\n        <div>\n            <div>before content<div>\n            text\n            <div>after content<div>\n        </div>\n        ```\n        :::\n    ```\n    效果：\n    :::demo\n    ```html\n    <div>\n        <div>before content<div>\n        text\n        <div>after content<div>\n    </div>\n    ```\n    :::\n    \n    ```\n    ::demo{path=\"/demo/flowchart.html\"}\n    ```\n    效果：\n    ::demo{path=\"/demo/flowchart.html\"}\n\n\n## 截图欣赏\n\n![图 1](/article/Pure%20Wiki%20%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92_2022-11-15_15-16-09-33.png)  \n![图 2](/article/Pure%20Wiki%20%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92_2022-11-15_15-16-09-58.png)  \n\n \n## 开发计划\n\n- [x] 图片alt显示\n- [x] 上一页与下一页\n- [x] 搜索(简陋实现，需改进)\n- [x] `mdx`全局组件实现，无需引入(初步实现)\n- [ ] 文章不显示在文件夹下，而是点击文件夹展示文章列表\n- [ ] 标签\n- [ ] 导出\n- [ ] 备份"},{"slug":"_计划","category":"blog","title":"计划","description":"","body":"## 学习\n- [ ] 学习在线解析ts,scss等文件的方法(https://flems.io/ 有源码映射可以看看)\n- [ ] vue或者其他的可编辑demo预览组件\n"},{"slug":"CSS/_推荐","category":"blog","title":"推荐","description":"","body":"\n## 牛人\n\n::collect[张鑫旭博客||一个CSS大神]{url=\"https://www.zhangxinxu.com/||网址\"}\n\n## 有技术的文章\n\n::collect[超出提示||CSS文本超出提示效果]{url=\"https://juejin.cn/post/6966042926853914654#heading-4||网址\"}\n"},{"slug":"CSS/css中line-height属性各个单位详解","category":"blog","title":"css中line-height属性各个单位详解","description":"","body":"\n我们都知道css中line-height属性用于调整行高，它的值有一些不同的单位，本文将详细介绍这些单位的作用和一些区别。\n\n语法规则如下\n\nline-height: normal | `<number>` | `<length>` | `<percentage>`\n\n如果子元素没有指定行高，那么将默认继承父元素的行高，继承的时候父元素行高带单位和不带单位有一些区别。\n\n为了方便，下面效果中我设置了背景颜色，以便观察行高到底是多少\n\n## normal\n\n设置值为normal时 行高根据浏览器默认决定，不同浏览器可能有不同的值。\n\n## 使用单位px\n\n使用px单位表示行高为多少像素\n:::demo\n```html\n<div style=\"font-size: 20px;\n\t\tline-height: 20px;\">\n\t\t\t<p style=\"background: orange;\">我是父元素 字体大小20px 行高25px</p>\n\t\t\t<div style=\"font-size:30px\n\t\t\t\">\n\t\t\t\t<p style=\"background: green;\">我是子元素的内容 字体大小30px 行高继承了父元素行高25px</p>\n\t\t\t</div>\n\t\t</div>\n```\n:::\n\n## 使用百分数或em单位\n\n120%和1.2em效果完全相同。如果某个元素设置行高为1.5em，它的行高就是 1.5乘以 它的字体大小\n\n:::demo\n```html\n<p style=\"font-size: 20px; line-height: 1.5em; background: #abcdef;\">我字体大小20px,行高1.5em 算出值就是20*1.5为30px</p>\n```\n:::\n\n如果上面这个例子 行高1.5em 其实它的行高是30px\n\n如果他有子元素，子元素继承的行高是它计算后的行高30px\n:::demo\n```html\n<div style=\"font-size: 20px; line-height: 150%;\">\n<p style=\"background: orange;\">我是父元素 字体大小20px 行高150% 计算后30px</p>\n<div style=\"font-size: 30px;\">\n<p style=\"background: green;\">我是子元素 字体30px 行高继承父元素行高30px</p>\n</div>\n</div>\n```\n:::\n\n## 不带单位\n\n不带单位表示行高为元素字体大小乘以该数字。如果子元素继承父元素的该属性，则只继承了该数字，实际行高由该系数乘以各个元素自己的字体大小而定\n\n:::demo\n```html\n<div style=\"font-size: 20px; line-height: 1.5;\">\n<p style=\"background: orange;\">我是父元素 字体大小20px 行高1.5 计算后30px</p>\n<div style=\"font-size: 30px;\">\n<p style=\"background: green;\">我是子元素 字体30px 行高继承系数1.5 计算后是45px</p>\n</div>\n</div>\n```\n:::\n\n## 总结\n\n由于不带单位的时候只继承了系数，推荐使用这种方式。"},{"slug":"CSS/filter和backdrop-filter使用","category":"blog","title":"filter和backdrop-filter使用","description":"","body":"\n## filter兼容性\n\n![filter兼容性](/article/filter和backdrop-filter使用/2023-02-04_04-00-49-25.png)  \n\n## backdrop-filter兼容性\n\n![backdrop-filter兼容性](/article/filter和backdrop-filter使用/2023-02-04_04-00-50-29.png)  \n\n## 是否使用说明\n\n可以看到两个特性的兼容性不太一样，`backdrop-filter`明显更新一些，可以想象微信浏览器可能都不支持，该属性可用于现代浏览器，主要是用于PC端，手机端兼容性不好可以换一种效果。\n\n## 区别\n\nbackdrop-filterCSS 属性可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。 因为它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明。"},{"slug":"CSS/有关伪元素的思考","category":"blog","title":"有关伪元素的思考","body":"\n## 情景演绎\n\n当时，我看到一个链接，很快啊，就点进去了，然后无意中发现他们的标题元素是根据文本的宽度下方有一个浅色的条纹，当时觉得这不停简单的吗，就是一个h2元素里面包一个行内块元素吗，有啥稀奇的。为了验证下猜想，于是果断按了`F12`,一检查，根本没有子元素，就是一个元素加上两个伪元素实现的，当时也没猜透是怎么实现的，现在经过严谨的分析，开始本文的解说。\n\n:::demo\n```html\n<style>\n    h2 {\n        display: inline;\n        width: auto;\n        background: linear-gradient(to bottom, transparent 70%, rgba(26, 188, 156, .3) 0) no-repeat;\n    }\n    h2::before {\n        content: \"\";\n        margin-top: 1.2em;\n        display: block;\n    }\n    h2::after {\n        content: \"\";\n        margin-top: 1.2em;\n        display: block;\n    }\n</style>\n<div>上部元素</div>\n<h2>\n    标题\n</h2>\n<div>下部元素</div>\n```\n:::\n\n大家可以查看框架源码，可以真切的看到就是只有一个元素。\n\n## 详细重现\n\n为了能够更加深入整个话题，我重新设计了一个Demo。\n\n:::demo\n```html\n<style>\n        .red{\n            background: red;\n            display: inline;\n        }\n\n        .red::before{\n            content: \"\";\n            display: block;\n            margin-top: 25px;\n        }\n\n        .red::after{\n            content: \"\";\n            display: block;\n            margin-bottom: 15px;\n        }\n    </style>\n    <div id=\"a\">aaaaaa</div>\n    <div id=\"output1\"></div>\n    \n    <div class=\"top\">top</div>\n    <div class=\"red\">aaaaaa</div>\n    <div class=\"bottom\">bottom</div>\n    <div id=\"output2\"></div>\n    <script>\n        document.getElementById(\"output1\").innerText = `普通元素高度为：${document.querySelector('#a').offsetHeight}px`\n        document.getElementById(\"output2\").innerText = `中间元素的高度为：${document.querySelector('.red').offsetHeight}px`\n    </script>\n```\n:::\n\n可以看到，中间的元素的高度等于`21+15=36`px,相当于`aaaaaa`本身的高度加上after伪元素`margin`高度。但是为啥不加上before伪元素的`margin`高度呢？实际上，不是不加，如果将css改成这样，那么可以看到元素就是61px了。\n\n:::demo\n<style>\n.red{\n    background: red;\n    overflow: hidden;\n}\n\n.red::before{\n    content: \"\";\n    display: block;\n    margin-top: 25px;\n}\n\n.red::after{\n    content: \"\";\n    display: block;\n    margin-bottom: 15px;\n}\n</style>\n<div id=\"a\">aaaaaa</div>\n<div id=\"output1\"></div>\n\n<div class=\"top\">top</div>\n<div class=\"red\">aaaaaa</div>\n<div class=\"bottom\">bottom</div>\n<div id=\"output2\"></div>\n<script>\n    document.getElementById(\"output1\").innerText = `普通元素高度为：${document.querySelector('#a').offsetHeight}px`\n    document.getElementById(\"output2\").innerText = `中间元素的高度为：${document.querySelector('.red').offsetHeight}px`\n</script>\n:::\n\n由此，可以推断出，伪元素实际是如下结构：\n```\n<div>\n    ::before\n    text\n    ::after\n</div>\n\n=>\n\n<div>\n    <div>before content<div>\n    text\n    <div>after content<div>\n</div>\n```\n\n这种结构刚好与上面的情况符合：\n- before margin的高度没有计算上。  \n    这是由于margin的合并造成的，第一个元素如果存在margin-top,会把整个父元素也顶下来，解决办法是触发BFC即可。关于margin合并，可以看[这篇文章](https://www.jianshu.com/p/a7ead28910f4)。\n- 为啥要注释`display: inline;`  \n    因为不变的话就会变成如下结构。但行内元素是不能嵌套块状元素的，否则块状元素会失去其特性，这点后面分析出来在写一篇文章。\n    ```\n    <span>\n        <div>before content<div>\n        text\n        <div>after content<div>\n    </span>\n    ```"},{"slug":"CSS/相对长度单位","category":"blog","title":"相对长度单位","description":"","body":"\n## 相对长度单位\n\n| 单位\t| 相对于 |\n|:--|:--|\n|`em`\t| 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width |\n|`ex`\t| 字符“x”的高度|\n|`ch`\t| 数字“0”的宽度|\n|`rem`\t| 根元素的字体大小|\n|`lh`\t| 元素的 line-height|\n|`vw`\t| 视窗宽度的 1%|\n|`vh`\t| 视窗高度的 1%|\n|`vmin`\t| 视窗较小尺寸的 1%（看宽度和高度哪个小）|\n|`vmax`\t| 视图大尺寸的 1%（看宽度和高度哪个大）|"},{"slug":"CSS/组合选择符","category":"blog","title":"组合选择符","description":"CSS组合选择符","body":"\n> \t组合选择符说明了两个选择器之间的关系。\n\nCSS组合选择符包括各种简单选择符的组合方式。\n\n在 CSS3 中包含了四种组合方式:\n\n- 后代选择器(以空格` `分隔)\n- 子元素选择器(以大于`>`号分隔）\n- 相邻兄弟选择器（以加号`+`分隔）\n- 后续兄弟选择器（以波浪号`~`分隔）\n\n## 后代选择器\n\n后代选择器用于选取某元素的后代元素。\n\n以下实例选取所有 `<p>` 元素插入到 `<div>` 元素中: \n\n:::demo\n```html\n<style>\ndiv p\n{\n  background-color:yellow;\n}\n</style>\n<div>\n    <p>p Text</p>\n    <p>p Text</p>\n    <p>p Text</p>\n    <p>p Text</p>\n    <div>div Text</div>\n</div>\n```\n:::\n\n## 子元素选择器\n与后代选择器相比，子元素选择器（Child selectors）只能选择作为某元素直接/一级子元素的元素。\n\n以下实例选择了`<div>`元素中所有直接子元素 `<p>` ：\n:::demo\n```html\n<style>\ndiv>p\n{\n\tbackground-color:yellow;\n}\n</style>\n<h1>Welcome to My Homepage</h1>\n<div>\n<h2>My name is Donald</h2>\n<p>I live in Duckburg.</p>\n</div>\n\n<div>\n<span><p>I will not be styled.</p></span>\n</div>\n\n<p>My best friend is Mickey.</p>\n```\n:::\n\n## 相邻兄弟选择器\n\n相邻兄弟选择器（Adjacent sibling selector）可选择紧接在另一元素后的元素，且二者有相同父元素。\n\n如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器（Adjacent sibling selector）。\n\n以下实例选取了所有位于 `<div>` 元素后的第一个 `<p>` 元素:\n:::demo\n```html\n<style>\ndiv+p\n{\n\tbackground-color:yellow;\n}\n</style>\n<h1>文章标题</h1>\n\n<div>\n<h2>DIV 内部标题</h2>\n<p>DIV 内部段落。</p>\n</div>\n\n<p>DIV 之后的第一个 P 元素。</p>\n\n<p>DIV 之后的第二个 P 元素。</p>\n```\n:::\n\n## 后续兄弟选择器\n后续兄弟选择器选取所有指定元素之后的相邻兄弟元素。\n\n以下实例选取了所有 `<div>` 元素之后的所有相邻兄弟元素 `<p>` : \n\n:::demo\n```html\n<style>\ndiv~p\n{\n\tbackground-color:yellow;\n}\n</style>\n<p>之前段落，不会添加背景颜色。</p>\n<div>\n<p>段落 1。 在 div 中。</p>\n<p>段落 2。 在 div 中。</p>\n</div>\n\n<p>段落 3。不在 div 中。</p>\n<p>段落 4。不在 div 中。</p>\n```\n:::"},{"slug":"CSS/行内元素的细小留白","category":"blog","title":"行内元素的细小留白","description":"一般来说，行内元素会出现几个像素的底部留白，这是浏览器决定的","body":"\n## 现象\n\n根据如下Demo,你可以清楚的看到上面的图片跟下面的文字有着明显的间隔。\n\n:::demo\n```html\n<style>\n.box{\n    border: 1px solid #efefef;\n    padding: 5px;\n}\n</style>\n    <div class=\"box\">\n        <!-- <div style=\"line-height: 0;\">\n            <span style=\"background-color: red;\">aa</span>\n            <span style=\"background-color: red;\">aa</span>\n        </div> -->\n        <div style=\"background-color: green;\">\n            <span>文字文字</span>\n            <img src=\"/favicon.svg\" alt=\"\">\n        </div>\n        <div style=\"background-color: red;clear: both;\">第二行文字</div>\n    </div>\n```\n:::\n\n## 产生原因\n\nimg属于行内块元素，div中的img的vertical-align默认属性是baseline。\n\n![图 1](/article/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%86%E5%B0%8F%E7%95%99%E7%99%BD_2022-11-21_21-14-25-56.png)  \n\n文本与图片的垂直对齐基线的位置并不是相同的：\n\n在**文本中，基线是字符的下边缘**。字符的下边缘和字符元素的底边是有一定的距离的（也就是行高）。\n**在图片中，基线就是图片的下边缘**。\n\n所以其实可以看到图片的底边是和字符的底边对齐的，这才导致了图片底部产生间隙。\n\n## 解决办法\n\n基于以上的原理，我们可以推导出解决办法：让字符的底边和图片的底边垂直对齐，就可以解决图片底部间隙的问题了。\n\n1. 将img标签设置为块级元素  \n    ```\n    img {\n\t    display: block;\n\t}\n    ```\n2. 设置图片的垂直对齐方式   \n    ```\n    img {\n        vertical-align: top/text-top/middle/bottom/text-bottom\n    }\n    ```\n3. 改变父元素的宽和高属性   \n    如果父对象的宽、高固定，图片大小随父对象而定，那么可以添加以下的一个属性来去掉图片下面的空间像素：\n    ```\n    div {\n        width: 100px;\n        height: 300px;\n        overflow: hidden;\n    }\n    ```\n4. 为img设置浮动    \n    ```\n    img {\n        float: left;\n    }\n    ```\n5. 为父元素设置`font-size: 0`\n    ```\n    div {\n        font-size: 0;\n    }\n    ```\n6. 为父元素设置`line-height: 0`\n    ```\n    div {\n        line-height: 0;\n    }\n    ```"},{"slug":"Manjaro/有关vscode中markdown-image粘贴图片的问题","category":"blog","title":"有关vscode中markdown-image粘贴图片的问题","description":"","body":"\n:collect[markdown-image||一个vscode中方便的粘贴插件]{url=\"https://github.com/imlinhanchao/vsc-markdown-image/blob/master/asserts/linux.sh||网址\"}是一个比较方便的粘贴插件，主要是符合我的需求。但是在linux上使用后发现总是粘贴中，就是不成功，研究了一下，过程如下：\n\n安装`xclip`,它主要是通过这个命令实现的。\n\n`markdown-image`是通过一个`linux.sh`插件运行的，如果你是用`manjaro`安装的`virual-studio-code-bin`,那么路径就类似于`/home/youname/.vscode/extensions/hancel.markdown-image-1.1.26/asserts/`下，试试先复制文字，然后`sh ./linux.sh`运行一下，复制图片，再运行一下，如果出现报错的话呢，我的是出现了未预期的符号，百度了一下可以通过[这个教程](https://blog.csdn.net/weixin_45785469/article/details/111647735)解决，就是`dos2unix linux.sh`一下，再试试复制文字或者图片运行，我这里发现仍旧报了一个模糊的重定向的错误，但是没关系，我试了试已经可以粘贴图片了。"},{"slug":"Vite/有关vite中使用环境变量","category":"blog","title":"有关vite中使用环境变量","description":"有关vite中使用环境变量","body":"\n根据官网的描述，如果需要给一个vite修改的配置的话，可以在项目的根目录下新建一个`vite.config.ts`文件，此时其中的修改会被应用到项目之中。\n不过，有可能在配置文件中也需要区分开发环境和生产环境进行配置的，因此这里详细介绍以下该配置文件的使用方法。\n\n## ts配置\n\n因为vite.config.ts是node环境中执行，因此可以与项目文件区分开，可以新建一个`tsconfig.node.json`文件代码如下：\n```json\n{\n    \"compilerOptions\": {\n        \"target\": \"es5\", // 最低兼容的版本\n        \"strict\": true, // 启用严格模式\n        \"composite\": true,\n        \"resolveJsonModule\": true,\n        \"esModuleInterop\": true,\n        \"module\": \"esnext\",\n        \"moduleResolution\": \"node\",\n        \"allowSyntheticDefaultImports\": true\n    },\n    \"include\": [\"vite.config.ts\", \"vite.env.d.ts\"]\n}\n```\n其中vite.env.d.ts可以声明一些与项目共有的类型，如：\n```ts\n/// <reference types=\"vite/client\" />\ninterface ImportMetaEnv {\n    readonly VITE_SENTRY_URL: string\n}\n\ninterface ImportMeta {\n    readonly env: ImportMetaEnv\n}\n```\n如此的话，只需要在`tsconfig.json`包含`vite.env.d.ts`即可，而不需包含`vite.config.ts`，做到类型隔离。\n\n## 详细说明\n\n在官网的[配置说明](https://cn.vitejs.dev/config/)中说明过这这里不再说明，这里针对在配置中如何判断不同的环境以及使用不同的环境变量。\n\n根据官方的说明，可以将代码写成如下格式\n```ts\nimport { ConfigEnv, defineConfig, loadEnv, UserConfigExport } from \"vite\"\n\nexport default defineConfig(({ command, mode, ssrBuild }) => {\n  const __PROD__ = mode === \"production\"\n  const __DEV__ = mode === \"development\"\n  const __STAGE__ = mode === \"staging\"\n  const config = <ImportMetaEnv>loadEnv(mode, process.cwd())\n  return {\n    ...\n  }\n})\n```\n- `command`参数包含`vite`运行时执行的命令，如执行了`vite serve`,则`command`是`serve`,执行了`vite build`,则`command`是`build`,应该就这两个值常用，一个表示开发环境，一个表示生产环境\n- `mode`在执行`vite serve`时是`development`，在执行`vite serve`时是`production`,也可以特别指定`vite build --mode staging`，此时运行的是生产配置，但`mode`是`staging`。同时，会自动加载`.env.`+`mode`值的文件，如mode是`development`，那么就会加载根目录`.env.development`的环境变量文件。`.env`会被所有模式加载\n- `config`声明之后就能使用`.env.[mode]`中的环境变量了，记住该文件中的环境变量只能以`VITE_`开头，如果在`.env.[mode]`中声明了变量`VITE_SENTRY_URL=123`,此时`config.VITE_SENTRY_URL`的值将会是123。最好自行在`ImportMetaEnv`添加类型说明，能有更好的智能提示体验。\n- `ssrBuild`暂时用不到"},{"slug":"Vue/_推荐","category":"blog","title":"推荐","description":"","body":"\n## vue2性能优化\n\n::collect[Vue2性能优化技巧||揭秘 Vue.js 九个性能优化技巧]{url=\"https://juejin.cn/post/6922641008106668045#heading-5||网址\"}"},{"slug":"🍰收藏/Linux","category":"blog","title":"Linux","description":"","body":"\n## 排行榜\n\n::collect[DistroWatch||DistroWatch页面点击排名统计数据是衡量 Linux 发行版和其他免费操作系统在本网站访问者中的受欢迎程度]{url=\"https://distrowatch.com/dwres.php?resource=popularity||网址\"}\n\n## 推荐\n\n::collect[zorinOS||Windows 和 macOS 的替代品，旨在使您的计算机更快、更强大、更安全且尊重隐私。]{url=\"https://zorin.com/||网址\"}\n"},{"slug":"🍰收藏/Typescript","category":"blog","title":"Typescript","body":"\n## 扩展\n\n::collect[实用类型||官方提供的高级类型工具]{ url=\"https://www.typescriptlang.org/docs/handbook/utility-types.html||网址\" }\n\n\n## 挑战\n\n::collect[类型体操||一个挑战Typescript的题库]{ url=\"https://github.com/type-challenges/type-challenges||Github\" }\n"},{"slug":"🍰收藏/前端功能","category":"blog","title":"前端功能","description":"","body":"\n编辑器：:collect[editorjs||通过很简单的配置就可以生成一个简单的富文本编辑器]{url=\"https://editorjs.io/\" Github=\"https://github.com/codex-team/editor.js\"}\n\n标记搜索结果中的文本：:collect[mark.js||针对每个用例的搜索词突出显示。可以与纯JavaScript一起使用，也可以作为jQuery插件使用。]{url=\"https://markjs.io/\" Github=\"https://github.com/julmot/mark.js/\"}\n"},{"slug":"🍰收藏/前端视觉","category":"blog","title":"前端视觉","body":"\n## 一些CSS模板\n\n::collect[getcssscan||阴影效果复制]{url=\"https://getcssscan.com/css-box-shadow-examples?ref=producthunt||网址\"}\n\n以下一些 :collect[前端动画库||27 个前端动画库让你的交互更加炫酷]{url=\"https://juejin.cn/post/7069945906518294536#comment||网址\"} 以下为抽出来的：\n[Animate.css](https://github.com/animate-css/animate.css) [Hover.css](https://github.com/IanLunn/Hover) [Magic.css](https://github.com/miniMAC/magic) [React Spring](https://github.com/pmndrs/react-spring) [React Reveal](https://github.com/rnosov/react-reveal) [Greensock](https://github.com/greensock/GreenSock-JS/) [Velocity.js](http://github.com/julianshapiro/velocity) [Lax.js](https://github.com/alexfoxy/lax.js) [Rellax.js](https://github.com/dixonandmoe/rellax) [three.js](https://github.com/mrdoob/three.js/) [wow.js](https://github.com/graingert/wow) [AniJS](https://github.com/anijs/anijs) [Anime.js](https://github.com/juliangarnier/anime/) [Typed.js](https://github.com/mattboldt/typed.js/) [Vivus](https://github.com/maxwellito/vivus) [Popmotion](https://github.com/popmotion/popmotion) [Granim.js](https://github.com/sarcadass/granim.js) [Kute.js](https://github.com/thednp/kute.js) [Simple Parallax](https://github.com/geosigno/simpleParallax.js) [Barba.js](https://github.com/barbajs/barba) [mo.js](https://github.com/mojs) [Particles.js](https://github.com/VincentGarreau/particles.js/) [tsParticles](https://github.com/matteobruni/tsparticles) [Rough Notation](https://github.com/rough-stuff/rough-notation) [Animate on Scroll](https://github.com/topics/animate-on-scroll) [Framer Motion](https://github.com/framer/motion) [React Motion](https://github.com/chenglou/react-motion) [animista.net](animista.net) [www.aminerman.com](www.aminerman.com)"},{"slug":"Vue/Vue3/有关组件props传递的问题","category":"blog","title":"有关组件props传递的问题","body":"\n在写vue组件的时候，总是想着props改变时怎么办，现在在这里解析一下，一般传递的值分为几种，一个是值类型，一个是引用类型，在Vue3这两种还分别分为了响应式类型和普通类型。\n\n下面分析以下这几种情况通过props传递时的一些特点\n\n## 值类型 + 普通类型\n\n这是最普通的传递方式\n\n## 值类型 + 响应式类型\n\n也是比较普通的传递方式，需要对props进行watch才能监听到其值的变化，因为获取值会先将其取值，其值时值类型，并不存在响应式\n\n## 引用类型 + 普通类型\n\n普通类型都不会触发watch，但使用其内部的值时发现其值是已经变化了的。\n\n## 引用类型 + 响应式类型\n\n一般用ref,reactive,shadowRef,shallowReactive\n\nref,reactive会做深层转换，将递归内部的值，如果是引用类型也会变成响应式类型，因此其内部的值也存在响应式，因此即使watch内部的值也是可以触发相应的\nshadowRef,shallowReactive只做浅层转换，内部的引用类型仍旧是之前的类型，之前是普通类型就是普通类型，之前是响应式类型就是响应式类型，普通类型不会触发响应。\n\n## 总结\n\n因此必须注意props中的是否是需要做动态变化的，如果需要，可以将值变成引用类型+深层转换+响应式类型，这样有响应式了。如果不需要动态变化，则普通类型就好了\n"},{"slug":"Vue/Vue2/Vue2响应式原理","category":"blog","title":"Vue2响应式原理","description":"","body":"\n## 观察器\n\n```js\nclass Observer {\n    constructor(data) {\n        // 如果传入的值不是对象或者不存在，就直接退出\n        if (!data || typeof data != \"object\") {\n            return;\n        }\n        // 绑定单一的值\n        this.data = data;\n        // 遍历所有可遍历属性\n        this.walk();\n    }\n\n    walk() {\n        for (const key in this.data) {\n            // 对每一个元素进行可监测处理\n            this.defineReactive(this.data, key, this.data[key]);\n        }\n    }\n    defineReactive(obj, key, val) {\n        // 如果传入的又是一个对象，那么需要对其子元素继续进行监测处理\n        new Observer(val);\n        // 定义可监测代码的主要函数\n        Object.defineProperty(obj, key, {\n            get() {\n                // 针对值获取的拦截处理，如console.log(obj.a)\n                console.log(\"1\");\n                return val;\n            },\n            set(newVaule) {\n                // 针对赋值的拦截处理，如obj.a = 100\n                if (val === newVaule) {\n                    return;\n                }\n                console.log(\"2\");\n                val = newVaule;\n                // 对新改变的值继续进行可监测处理\n                new Observer(newVaule);\n            },\n        });\n    }\n}\n```\n\n使用方法：\n\n```\nlet data = {\n    name: \" cjg\",\n    obj: {\n        name: \"zht\"\n    }\n}\n\nlet ob = new Observer(data);\nob.defineReactive(data,'aa',5)\ndata.aa=4\ndata.aa\n//--->\n//2 // 先是赋值\n//1 // 然后值获取\n```\n\n## 依赖收集\n\n```js\n// 观察器\n***\n  defineReactive(obj, key, val) {\n    const dep = new Dep(); // 每一个值定义一个依赖管理\n    new Observer(val);\n    Object.defineProperty(obj, key, {\n      get() {\n        console.log('1');\n        if (Dep.target) { // 如果管理器绑定了一个监听器，那么就将可监测值推入管理队列中\n          dep.addSub(Dep.target); // 推入操作\n        }\n        return val;\n      },\n      set(newVaule) {\n        if (val === newVaule) {\n          return;\n        }\n        val = newVaule;\n        new Observer(newVaule);\n        dep.notify(); // 依赖刷新\n      }\n    })\n  }\n***\n```\n\n```js\n// 依赖管理器\nclass Dep {\n    constructor() {\n        this.subs = [];\n    }\n    addSub(sub) {\n        if (this.subs.indexOf(sub) < 0) {\n            this.subs.push(sub);\n        }\n    }\n    notify() {\n        this.subs.forEach((sub) => {\n            sub.update();\n        });\n    }\n}\n// 用户绑定Watcher\nDep.target = null;\n```\n\n## 监听器\n\n```js\nclass Watcher {\n    // vm: 响应式对象\n    // keys: 响应式对象的属性\n    // updateCb: 数值更新时的回调\n    constructor(vm, keys, updateCb) {\n        this.vm = vm;\n        this.keys = keys;\n        this.updateCb = updateCb;\n        this.value = null;\n        this.get();\n    }\n    // 监听器绑定\n    get() {\n        // 依赖管理器设置该监听器\n        Dep.target = this;\n        // 对属性的拆分，例如obj.a.a\n        const keys = this.keys.split(\".\");\n        // 获取响应式对象\n        let value = this.vm;\n        // 对属性进行值的获取，直到最终值\n        keys.forEach((_key) => {\n            // 这里由于value[_key]获取了值，会执行上面监听器中defineProperty的get属性函数,这样get函数中的依赖收集变会启动并收集该属性.\n            value = value[_key];\n        });\n        // 旧值的临时存储\n        this.value = value;\n        // 因为上边依赖已经收集完毕,所有可以去掉了,方便下一个响应式对象的设置\n        Dep.target = null;\n        return this.value;\n    }\n    update() {\n        // 依赖更新,值在被更新的时候执行的函数\n        const oldValue = this.value;\n        const newValue = this.get(); //获取最新值\n        if (oldValue != newValue) {\n            this.updateCb(oldValue, newValue);\n        }\n    }\n}\n```\n\n[示例](https://flems.io/#0=N4IgtglgJlA2CmIBcBWFA6A7ATgDQgGMB7AOwGciFlDLYBDABzPihHwDMIEzkBtUEnTCIkIdAAsALmFhsaJSfAXUQAX1wChIsQCse+YgqWTqBemTIACAPIAjZgCcAbvAeXgAHRKWflw2UkHAFcCSSIHAAooOkk6AEp3L19kywB6VMtAIM1AHPNAAnlAU0VAELdAHgVAWDlAejNAT+1AQxjANCNAUADSwA1tQAp1QBh-wEYdQBe3QFLjQAAEwC-FJJSfCHZLCIBCaNjLAB85y0kATwZ4InGZuktJgF5LDxAiWx14UMOEz28RlId4SSCHEgBuYZHVN5T0y0BFv0As7UAqsqAADkSp9kpJxBAyOgtpZ9ltXtcRt9ALIJgDDlQACRoBIc0A98rowB6OoByAzBvghUPQAHc6LAANYROKI5IfEifKm0+mJJEpdjhCb+SSWGnwZaWCDeMnQraXEnIjKVQDz1kDAFRygGFFQAEvoBt+MAMhE4wCLboBpW0AIJqAMBcZSkJTD4JwSPAAErwOihCAuCIWra4QXCj1umJ0XhC5YAXQZZuZTM+UCtYrtDqdLuOOg9AY9Tmp0q5yX5lkjDDhlhtFMsABF4Ax6c80hlFUrin9AJJyysAufKANVjAIXepozvgLNnsrhckVTsBDnZ8dlOoUt1vgAAUHEQ1g4VhEE0mvZybr4AOb3DlXDfJMYTEsMdCxBzbySXStZbLtwAWav9AGFyyt1gBoVO9tQDFCYAJOQ6gDAdPV9WKQAK43ydtAHw0wB0JUAWjkzRGHN0DoGAAGUglsCJj1POhz3uBlr1AwBZk0AHXk4N8MN9x8O4HieSxB0Zfd1FI5hJAiAsADU6CCBB0wo0ZxgiQc4V2fZ2M47j114yj7keF5SJ8ciKMEkT4ApDiuPgeiKO7OxHH7ViVLU7jNP3BCSCISQxmWctrxbQB2JUABtNSIUlJVDiT5mWZLxvhbe8vDMOgLGLUsJJ8flglCcJdzNC0yDQqx9l4QNjOcpCoFQ9DYtsHibkPV1IWhTLoTFSMAA9rHYCJMoSAAeSwAAZsoomK4vQBggjIcRKrQ4cN2c5yzIs9grMa818vQQr0B5BwAFFHU6rqsrhAA+EL90y9AggYGZ4HLUMerIrxmW+QAKV0AdiN-gAdRiAhxFcLxMLPC88xILjYERPzzCsK7JBu1xVu+JwwCQSxAFmVQAUvUAeH0ak+b4AzIYHwah6pCiJGGMk27aAGFbGBwAHU2KQAXs3swA300KQA9tUAYBjPjCkIwgHMBV2WMgPQxmJ4GxkbwTGwG80B4yufJOG8zh-nSTG1nFGxvMJfZ2xRZ8C1ByCeBnte+WljGi9dq5ZzvjfB8-k+LXOd8by22NO9AD7owA7f0AU+j9bNB7sKe-YJXV75KiJQpADGjQAwJTaQBo+UyBNEMQs0syF12xrh8aGFgCAWMOdALndjJAHbgwA15UR6GR0sBABSVlWo-JPmzQ9oltWKQpM7aLpAAYlQAAc0ACb9ijNGOptmm6IgiAB9AMEl2Fa91475AE34wAZxMARldADi5QveD74VA0zx9ijaQAseUAcyMtUAKDlACN0-XoMjKdZ3nVwVkKC8iUAX8VcdwUfAHYLC8b+gwoW0ANlNADG0wAN5TXwB6FUACqVABuep-W2RJk652SIXXm1JlbzwDElPaqdLCAHPTKugAWOWJk0QAFQrRW5jAoutF8FIMAAdqgAuOW3oATviWyACfdQA836f0ADHagBV61wNiHEgBTuUAN3KgBI40fLgQAnaaAH75QA0HLKmzsjG2jtSxYRwgKESaszRURkhrEuRD3KfBllFXOZsia4GKC0QA1RFE0KMTQAmApb0KDfcOpAAiWEoFADisBlZ5kVmo3OWZRJOIIRaY2FZ0iZwbvZVuudcr2Mcc4vY+YDL4JNiMC0MtsbLlgA4-BHpPHK32u8dRJBPIkHztmX0eZh4+EEMIYGhw-A6E3IcXAnwEzA2KSkUp8BykgAAF5SEONk3J+TjjPRUj2XSrgoi+mHFsdAzTdiHACtELpJBuzfV+pEY4HpDjjOaTUyw7AggkCdKQJJKSvFpOiV4uIw9-CUHgOgWARBNwHPCfAY5qkYmHTcvMgZizbrLNsKskA6ytCbO2bsiy+ywmpKic8055ybGXOubc+54L0nwDea5Lw-zhBTJADMgAjLiw4chmAID2eQaguKAAsSBsUAA4AC02K6oADYkB1TUBoEAzTqDoAIBYOQhhFDKFEGoQMqggA)\n"},{"slug":"前端/基础知识/null和undefined究竟有何区别","category":"blog","title":"null和undefined究竟有何区别","description":"","body":"\n## 简单区分\n\n总的来说 `null` 和 `undefined` 都代表空，主要区别在于 `undefined` 表示尚未初始化的变量的值，而 `null` 表示该变量有意缺少对象指向。\n\n- `undefined`\n    这个变量从根本上就没有定义\n    隐藏式 空值\n- `null`\n    这个值虽然定义了，但它并未指向任何内存中的对象\n    声明式 空值\n\n## MDN 中给出的定义\n- `null`\n    值 null 是一个字面量，不像 undefined ，它不是全局对象的一个属性。null 是表示缺少的标识，指示变量未指向任何对象。把 null 作为尚未创建的对象，也许更好理解。在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。\n\n- `undefined`\n    undefined 是 全局对象 的一个属性。也就是说，它是全局作用域的一个变量。 undefined 的最初值就是原始数据类型 undefined 。\n\n## 图片定义\n![null和undefined](/article/null和undefined究竟有何区别/2023-01-19_19-11-38-05.png)  \n\n## 表现形式\n\n在更深入理解 null 和 undefined 的区别前，我们首先要知道 null 和 undefined 在 JS 中有什么不同的表现形式，用以方便我们更好的理解 null 和 undefined 的区别。\n\n### typeof\n\n```\ntypeof null  // 'object'\ntypeof undefined  // 'undefined'\n```\n\n### Object.prototype.toString.call\n\n```\nObject.prototype.toString.call(null)       // '[object Null]'\nObject.prototype.toString.call(undefined)  // '[object Undefined]'\n```\n\n### == 与 ===\n\n```\nnull == undefined  // true\nnull === undefined  // false\n!!null === !!undefined  // true\n```\n\n### Object.getPrototypeOf(Object.prototype)\n\nJavaScript 中第一个对象的原型指向 null 。\n```\nObject.getPrototypeOf(Object.prototype)  // null\n```\n\n### + 运算 与 Number()\n\n```\nlet a = undefined + 1  // NaN\nlet b = null + 1  // 1\nNumber(undefined)  // NaN\nNumber(null)  // 0\n```\n\n### JSON\n\n```\nJSON.stringify({a: undefined})  // '{}'\nJSON.stringify({b: null})  // '{b: null}'\nJSON.stringify({a: undefined, b: null})  // '{b: null}'\n```\n\n### let undefiend = 'test'\n\n```\nfunction test(n) {\n    let undefined = 'test'\n    return n === undefined\n}\n\ntest()           // false\ntest(undefined)  // false\ntest('test')     // ture\n\nlet undefined = 'test'  // Uncaught SyntaxError: Identifier 'undefined' has already been declared\n```\n\n## 深入探索\n\n### 为什么 typeof null 是 object？\n\ntypeof null 输出为 'object' 其实是一个底层的错误，但直到现阶段都无法被修复。\n\n原因是，在 JavaScript 初始版本中，值以 32位 存储。前 3位 表示数据类型的标记，其余位则是值。\n对于所有的对象，它的前 3位 都以 000 作为类型标记位。在 JavaScript 早期版本中， null 被认为是一个特殊的值，用来对应 C 中的 空指针 。但 JavaScript 中没有 C 中的指针，所以 null 意味着什么都没有或者 void 并以 全0(32个) 表示。\n\n因此每当 JavaScript 读取 null 时，它前端的 3位 将它视为 对象类型 ，这也是为什么 typeof null 返回 'object' 的原因。\n\n### 为什么 Object.prototype.toString.call(null) 输出 '[object Null]'\n\ntoString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。\n\n### JavaScript 万物皆对象，为什么 xxx.toString() 不能返回变量类型？\n\n这是因为 各个类中重写了 toString 的方法，因此需要调用 Object 中的 toString 方法，必须使用 toString.call() 的方式调用。\n\n对于 Object 对象，直接调用 toString()  就能返回 '[object Object]' 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。\n\n### 为什么 == 和 === 对比会出现 true 和 false ？\n\n很多文章说： undefined 的布尔值是 false ， null 的布尔值也是 false ，所以它们在比较时都转化为了 false ，所以 undefined == null 。\n实际上并不是这样的。\nECMA 在 11.9.3 章节中明确告诉我们：\n\n>1. If x is null and y is undefined, return true.\n>2. If x is undefined and y is null, return true.\n\n### 为什么 null + 1 和 undefined + 1 表现不同？\n\n这涉及到 JavaScript 中的隐式类型转换，在执行 加法运算 前，隐士类型转换会尝试将表达式中的变量转换为 number 类型。如： '1' + 1 会得到结果 11。\n\n- null 转化为 number 时，会转换成 0\n- undefined 转换为 number 时，会转换为 NaN\n\n至于为什么执行如此的转换方式，我猜测是 JavaScript 早期的一个糟糕设计。\n\n从语言学的角度来看：\nnull 意味着一个明确的没有指向的空值，而 undefined 则意味着一个未知的值。\n在某种程度上， 0 意味着数字空值。\n这虽然看起来有些牵强，但是我在这一阶段能所最能想到的可能了。\n\n### 为什么 JSON.stringify 会将值为 undefined 的内容删除？\n\n其实这条没有很好的解释方式， JSON 会将 undefined 对应的 key 删除，这是 JSON 自身的转换原则。\n\n在 undefined 的情况下，有无该条数据是没有区别的，因为他们在表现形式上并无不同：\n```\nlet obj1 = { a: undefined }\nlet obj2 = {}\n\nconsole.log(obj1.a)  // undefined\nconsole.log(obj2.a)  // undefined\n```\n但需要注意的是，你可能在调用接口时，需要对 JSON 格式的数据中的 undefied 进行特殊处理。\n\n### 为什么 let undefiend = 'test' 可以覆盖掉 JavaScript 自身的 undefined？\n\nJavaScript 对于 undefined 的限制方式为全局创建了一个只读的 undefined ，但是并没有彻底禁止局部 undefined 变量的定义。\n\n据说在 JavaScript 高版本禁止了该操作，但我没有准确的依据。\n\n请在任何时候，都不要进行 undefined 变量的覆盖，就算是你的 JSON 转换将 undefined 转换为 '' 。也不要通过该操作进行，这将是及其危险的行为。\n\n## 总结\n\n### 关于使用 undefined 还是 null\n\n这是一条公说公有理婆说婆有理的争议内容。\n本人更倾向于使用 null ，因为这是显示定义空值的方式。我并不能给出准确的理由。\n\n但关于使用 undefined 我有一条建议：\n如果你需要使用 undefined 定义空值，请不要采取以下两种方式：\n\n- let a;\n- let a = undefined;\n\n进而采取下面这种方式显式声明 undefined ：\n\n- let a = void 0;\n\n## 参考链接\n> [深入探究：null 和 undefined 究竟有何区别？](https://juejin.cn/post/7051144396615450655#comment)\n\n"},{"slug":"前端/基础知识/数组过滤","category":"blog","title":"数组过滤","description":"数组过滤","body":"\n## 前言\n\n本人最习惯用 forEach, filter, indexOf 来筛选数组，现在深入学习下新方法。\n\n## filter\n\n1. filter 遍历数组会返回一个新数组\n2. 循环次数就是数组的长度\n\n```\nlet arr = [1,2,3,4,5]\nlet newArr = arr.filter((item,index) => {\n\treturn item>3\n})\nconsolo.log(newArr)\n```\n\n## some\n\n1. 符合条件时返回 ture，否则返回 false\n2. 循环次数小于等于数组长度\n3. 当条件满足时，就会终止循环，并返回 ture，如果没有满足判断条件的，会遍历整个数组\n\n```\nlet arr = [1,2,3,4,5]\nlet newArr = arr.some((item,index) => {\n\treturn item>3\n})\nconsole.log(newArr)\n```\n\n## map\n\n1. 会遍历整个数组的循环\n2. 会得到一个新的数组，返回数组的项是什么取决于 map 函数中的调用方法\n\n```\nlet arr=[1,2,3,4,5，6]\nlet newArr = arr.map((item,index) => {\n\treturn item === 1\n})\nconsole.log(newArr)\n```\n\n## forEach\n\n类似于正常的 for 循环，可改变原来数组中的内容；forEach 函数中 return 会失效，因为 foreach 内部封装的有 callback\n\n```\nlet a = [1,2,3]\na.forEach((item,index) => {\n\ta[index] = item + 1\n})\nconsole.long(a)\n```\n\n## find\n\n1. 有返回值，符合条件会返回一个数组中的那个项，如对象\n2. 循环次数小于或等于数组长度\n\n```\nb=[{a:1},{b:2},{c:3}]\nb.find((item,index) => {return item.b===2})\n```\n\n## findIndex\n\n1. 会返回符合条件的那个项的索引值，否则返回-1\n2. 循环次数小于或等于数组长度\n\n```\nb=[{a:1},{b:2},{c:3}]\nb.findIndex((item,index) => {return item.b===2})\n```\n\n## every\n\n1. 用于检测所有数组项中是否都符合某个条件，如果都符合则返回 true，只要有一项不符合就返回 false 并终止遍历\n2. 循环次数小于或等于数组长度\n\n```\na=[2,2,2,2,3]\na.every((item,index) => {\n\treturn item===2\n})\n```\n"},{"slug":"小说/短篇/城间小事","category":"blog","title":"城间小事","description":"城内莫名出现的黑衣人，地上用血绘制的符文，暗夜里隐隐散发的紫光，究竟暗处存在着什么？","body":"\n是夜，在黑暗的巷子里，呼呼的风声听着格外刺耳，但这也是小龙唯一的居所了。他身上披着破旧的薄衫，紧紧裹着一层直板，在一个拐角的角落里瑟瑟发抖。也许过不了多久，他就得冷死在这里了。\n\n“沙沙”，脚踩着巷口地上的沙子，一个白衣女人紧裹着一件毛皮大衣，缓缓的走进了巷子，手中还搭着一件小被子，上面绣着几朵艳丽的玫瑰。她随手将被子盖在小龙的身上，身后闪进一个全身黑衣的女人，将小龙用被子裹着抱了起来。随后，两人一前一后离开了这个地方。\n"}]